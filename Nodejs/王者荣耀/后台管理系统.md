## 一. 初始化

```
三端项目：server admin web
```

```
server:
	直接新建文件夹server
	npm init -y：生成package.json，package.json中增加一个执行脚本，
				现在npm run serve就可以启动后台了，使用nodemon可以自动更新，
				不用每次修改都手动重启项目，nodemon需要全局安装，npm i -g nodemon
	新建index.js：入口文件
```

```json
"scripts": {
    "serve": "nodemon index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
```

```
admin:
	vue create admin 不使用history模式
```

```
web: 
	vue create web 不使用history模式
```

至此初始化完成

## 二. 分类管理

### 1. 后台管理基础界面搭建

#### 1.1 界面初始化

> admin目录下打开终端
> vue add element: 安装element-ui插件 （完全引入 不重写 中文）

> 1. views下增加Main.vue，复制container布局容器
> 2. router > index.js中添加Main.vue的路由，删掉about组件及路由
> 3. App.vue中删掉无关代码，加上router-view
>
> 以上三步，页面上就能呈现一个后台管理的页面了

views目录下增加Main.vue组件，复制element中的container布局容器，加上template

```html
<template>
  <el-container style="height: 500px; border: 1px solid #eee">
    <el-aside width="200px" style="background-color: rgb(238, 241, 246)">
      <el-menu :default-openeds="['1', '3']">
        <el-submenu index="1">
          <template slot="title"><i class="el-icon-message"></i>导航一</template>
          <el-menu-item-group>
            <template slot="title">分组一</template>
            <el-menu-item index="1-1">选项1</el-menu-item>
            <el-menu-item index="1-2">选项2</el-menu-item>
          </el-menu-item-group>
          <el-menu-item-group title="分组2">
            <el-menu-item index="1-3">选项3</el-menu-item>
          </el-menu-item-group>
          <el-submenu index="1-4">
            <template slot="title">选项4</template>
            <el-menu-item index="1-4-1">选项4-1</el-menu-item>
          </el-submenu>
        </el-submenu>
        <el-submenu index="2">
          <template slot="title"><i class="el-icon-menu"></i>导航二</template>
          <el-menu-item-group>
            <template slot="title">分组一</template>
            <el-menu-item index="2-1">选项1</el-menu-item>
            <el-menu-item index="2-2">选项2</el-menu-item>
          </el-menu-item-group>
          <el-menu-item-group title="分组2">
            <el-menu-item index="2-3">选项3</el-menu-item>
          </el-menu-item-group>
          <el-submenu index="2-4">
            <template slot="title">选项4</template>
            <el-menu-item index="2-4-1">选项4-1</el-menu-item>
          </el-submenu>
        </el-submenu>
        <el-submenu index="3">
          <template slot="title"><i class="el-icon-setting"></i>导航三</template>
          <el-menu-item-group>
            <template slot="title">分组一</template>
            <el-menu-item index="3-1">选项1</el-menu-item>
            <el-menu-item index="3-2">选项2</el-menu-item>
          </el-menu-item-group>
          <el-menu-item-group title="分组2">
            <el-menu-item index="3-3">选项3</el-menu-item>
          </el-menu-item-group>
          <el-submenu index="3-4">
            <template slot="title">选项4</template>
            <el-menu-item index="3-4-1">选项4-1</el-menu-item>
          </el-submenu>
        </el-submenu>
      </el-menu>
    </el-aside>
    
    <el-container>
      <el-header style="text-align: right; font-size: 12px">
        <el-dropdown>
          <i class="el-icon-setting" style="margin-right: 15px"></i>
          <el-dropdown-menu slot="dropdown">
            <el-dropdown-item>查看</el-dropdown-item>
            <el-dropdown-item>新增</el-dropdown-item>
            <el-dropdown-item>删除</el-dropdown-item>
          </el-dropdown-menu>
        </el-dropdown>
        <span>王小虎</span>
      </el-header>
      
      <el-main>
        <el-table :data="tableData">
          <el-table-column prop="date" label="日期" width="140">
          </el-table-column>
          <el-table-column prop="name" label="姓名" width="120">
          </el-table-column>
          <el-table-column prop="address" label="地址">
          </el-table-column>
        </el-table>
      </el-main>
    </el-container>
  </el-container>
</template>
<style>
  .el-header {
    background-color: #B3C0D1;
    color: #333;
    line-height: 60px;
  }
  
  .el-aside {
    color: #333;
  }
</style>

<script>
  export default {
    data() {
      const item = {
        date: '2016-05-02',
        name: '王小虎',
        address: '上海市普陀区金沙江路 1518 弄'
      };
      return {
        tableData: Array(20).fill(item)
      }
    }
  };
</script>
```

router > index.js 加上Main.vue的路由，删掉About的路由及组件

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '../views/Home.vue'
import Main from '../views/Main.vue'

Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    name: 'Main',
    component: Main
  },
  
]

const router = new VueRouter({
  routes
})

export default router

```

App.vue 加上router-view，无关的东西都删掉

```html
<template>
  <div id="app">
    <router-view/>
  </div>
</template>

<script>


export default {
  name: 'app',
  components: {
   
  }
}
</script>

<style>

</style>

```

#### 1.2 修改样式内容

App.vue

```css
<style>
/* 边距都变为零 */
html,body {
  margin: 0;
  padding: 0;
}
</style>

```

Main.vue

最外层的容器修改了高度，去掉了边框

```html
<el-container style="height: 100vh; ">
```

1. 删掉了el-aside的一些子选项，只剩下一个el-submenu，一个el-menu-item-group

   现在界面上左侧的导航区只剩下了内容管理 > 分类 > 新建分类 + 分类列表

2. 在el-menu中添加router属性，el-menu-item的index上加上跳转路径，这样就有了点击跳转的效果

```html
<el-aside width="200px" style="background-color: rgb(238, 241, 246)">
      <el-menu router :default-openeds="['1', '3']">
        <el-submenu index="1">
          <template slot="title"><i class="el-icon-message"></i>内容管理</template>
          <el-menu-item-group>
            <template slot="title">分类</template>
            <el-menu-item index="/categories/create">新建分类</el-menu-item>
            <el-menu-item index="/categories/list">分类列表</el-menu-item>
          </el-menu-item-group>          
        </el-submenu>
      </el-menu>
    </el-aside>
```



### 2. 新建分类

#### 2.1 初始化

views中创建CategoryEdit.vue组件

```html
<template>
  <div class="category-edit">
    <h1>新建分类</h1>
  </div>
</template>
```

在router > index.js中配置路由，CategoryEdit是主页面的子路由

```js
const routes = [
  {
    path: '/',
    name: 'Main',
    component: Main,
    children: [
      {path: '/categories/create', component: CategoryEdit}
    ]
  },
]
```

Main.vue

```html
<el-main>
    <router-view></router-view>
</el-main>
```

以上三步，点击创建分类时，页面主题内容就会变成创建分类的组件内容

#### 2.2 修改Category.vue

增加了表单，添加表单提交方法

```html
<template>
  <div class="category-edit">
    <h1>新建分类</h1>
    <!-- 点击保存时，执行save方法，.native监听原生组件，.prevent阻止表单默认行为，
          不会跳转页面 -->
    <el-form label-width="120px" @submit.native.prevent="save">
      <el-form-item label="名称">
        <!-- 双向绑定数据，model就是数据库文档 -->
        <el-input v-model="model.name"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" native-type="submit">保存</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  data() {
    return {
      model: {}
    }
  },
  methods: {
      save() {
          
      }
  }
}
</script>  

```

#### 2.3 axios封装

admin

```
npm i axios
```

src下新建http.js，用于axios的封装

```js
import axios from 'axios'

const http = axios.create({
  baseURL: 'http://localhost:3000/admin/api'
})

export default http
```

main.js

```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import './plugins/element.js'
// 导入http
import http from './http'

Vue.config.productionTip = false
// 将$http挂载到Vue原型上，其他组件都可以用this.$http来发起网络请求了
Vue.prototype.$http = http

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')

```

#### 2.4 后台初始化

```
npm i express@next mongoose cors // 安装express（可能是最新版） mongoose cors(允许跨域的)
```

server > index.js

开启服务器

```js
const express = require('express')

const app = express()

app.listen(3000, () => {
  console.log('http://localhost:3000')
})
```

server下新建routes目录，用来写路由相关的内容，routes下新建admin目录，表示admin的路由

admin下新建index.js，写admin的路由接口

```js
// 导出一个函数，给server > index.js使用
// app是个形参，将会传过来express的实例
module.exports = app => {
  const express = require('express')
  // 子路由
  const router = express.Router()
  router.post('/categories', async (req, res) => {

  })
  // 中间件，使用这个中间件就可以将/admin/api拼接到前面的路由中
  // /categories变成/admin/api/categories，避免每个路由都写/admin/api
  // server运行在http://localhost:3000端口
  app.use('/admin/api', router)
}
```

server > index.js

```js
const express = require('express')

const app = express()

// 执行admin > index.js，并且传入app
require('./routes/admin')(app) 

app.listen(3000, () => {
  console.log('http://localhost:3000')
})
```

#### 2.5 连接数据库

server下新建plugins，plugins下新建db.js，用来写数据库相关操作

```js
// 导出函数，参数期待express实例
module.exports = app => {
  const mongoose = require('mongoose')
  // 连接admin这个数据库，和视频有区别，注意注意！
  mongoose.connect('mongodb://127.0.0.1:27017/node-vue-admin', {
    useNewUrlParser: true,
    useUnifiedTopology: true
  })
}
```

server下新建models，models下新建Category.js，用来写Category接口需要的集合模型

```js
// 定义Category的模型，数据库中会变成复数
const mongoose = require('mongoose')

const schema = new mongoose.Schema({
  name: { type: String }
})

module.exports = mongoose.model('Category', schema)
```

#### 2.6 后台接口

server > admin > index.js

```js
// 后缀名js可以省略，导入Category模型
  const Category = require('../../models/Category')
  // /categories的post请求接口
  router.post('/categories', async (req, res) => {
    // 根据req.body创建文档，返回的是数据库中的文档，包含id name等字段
    const model = await Category.create(req.body)
    res.send(model)
  })
```

index.js 全貌

```js
// 导出一个函数，给server > index.js使用
// app是个形参，将会传过来express的实例
module.exports = app => {
  const express = require('express')
  // 子路由
  const router = express.Router()
  // 后缀名js可以省略
  const Category = require('../../models/Category')
  // /categories的post请求接口
  router.post('/categories', async (req, res) => {
    // 根据req.body创建文档，并文档传给客户端
    const model = await Category.create(req.body)
    res.send(model)
  })
  // 中间件，使用这个中间件就可以将/admin/api拼接到前面的路由中
  // /categories变成/admin/api/categories，避免每个路由都写/admin/api
  app.use('/admin/api', router)
}
```

server > index.js 

```js
const express = require('express')

const app = express()

// 需要用到req,res的属性就需要使用这个中间件  (增加)
app.use(express.json())
// 允许跨域
app.use(require('cors')())

// 执行admin > index.js，并且传入app (增加)
require('./routes/admin')(app) 

// 连接数据库
require('./plugins/db')(app)

app.listen(3000, () => {
  console.log('http://localhost:3000')
})

```

#### 2.7 前端请求

admin > src > views > CategoryEdit.vue

点击保存按钮，就触发save方法

```js
/* post请求，提交到categories，req.body可能就是this.model，提交完就跳转到list界面 */
// axios的baseURL: 'http://localhost:3000/admin/api'
async save() {
    // 请求体是{name: 'news'}，就是this.model
    const res = await this.$http.post('categories', this.model)
    this.$router.push('/categories/list')
    this.$message({
        type: 'success',
        message: '保存成功'
    })
}
```

### 3. 分类列表

#### 3.1 初始化

admin > src > views新建CategoryList.vue

```html
<template>
  <div class="category-list">
    <h1>分类列表</h1>
  </div>
</template>
```

router > index.js 加入路由

```js
const routes = [
  {
    path: '/',
    name: 'Main',
    component: Main,
    children: [
      {path: '/categories/create', component: CategoryEdit},
      {path: '/categories/list', component: CategoryList},
    ]
  },
]
```

修改CategoryList.vue

加上了一个表格，表格有id和名称两列，数据来源于items，每一列的数据来源于items的属性

```html
<template>
  <div class="category-list">
    <h1>分类列表</h1>
    <!-- 表格数据items，prop大概是items里对象的属性 -->
    <el-table :data="items">       
      <el-table-column prop="_id" label="ID" width="230">
      </el-table-column>
      <el-table-column prop="name" label="分类名称">
      </el-table-column>     
    </el-table>
  </div>
</template>


<script>
export default {
  data() {
    return {
      items: []
    }
  },
}
</script>
```

#### 3.2 后台接口

前端需要展示列表数据

server > routes > admin > index.js

```js
// 分类列表的接口
router.get('/categories', async (req, res) => {
    const items = await Category.find().limit(10)
    res.send(items)
})
```

#### 3.3 前端请求数据

views > CategoryList.vue

```js
methods: {
    async fetch() {
      const res = await this.$http.get('categories')
      // res.data才是数据
      this.items = res.data
    }
  },
  // 组件创建时，就发起请求
  created() {
    this.fetch()
  }
```

### 4. 编辑分类

#### 4.1 初始化

CategoryList.vue 添加了一列，加上编辑按钮，监听点击事件，点击跳转

```html
<el-table-column
    fixed="right"
    label="操作"
    width="180">
    <!-- scope.row当前行的文档 -->
    <template slot-scope="scope">
        <el-button type="primary"
        @click="$router.push(`/categories/edit/${scope.row._id}`)" 
        size="small">编辑</el-button>
    </template>
</el-table-column> 
```

router > index.js 配置路由

编辑分类和新建分类使用同一个组件，并且传递参数

```js
{path: '/categories/edit/:id', component: CategoryEdit, props: true},
```

修改CategoryEdit.vue

```js
// 可以获得路由的params参数
  props: {
    id: {}
  },
```

根据有无id动态展示编辑还是新建

```html
<h1>{{id  ? '编辑' : '新建'}}分类</h1>
```

#### 4.2 获取原始数据

因为编辑分类，一开始要在页面上显示原来的信息，所以需要获取数据

server > routes > admin > index.js

```js
// 获取详情页的数据
router.get('/categories/:id', async (req, res) => {
    const model = await Category.findById(req.params.id)
    res.send(model)
})
```

#### 4.3 前端发起请求

```js
methods: {
    // 省略了之前的函数
    
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`categories/${this.id}`)
      this.model = res.data
    }
  },
  created() {
    // 有id的时候就去获取
    this.id && this.fetch()
  }
```

#### 4.4 后台修改文章

```js
// 编辑文章的接口
router.put('/categories/:id', async (req, res) => {
    // 第一个参数是id，第二个参数是更新的内容
    const model = await Category.findByIdAndUpdate(req.params.id, req.body)
    res.send(model)
})
```

#### 4.5 前端请求修改

修改和新建的请求写在了一起，切换条件是是否有id

```js
methods: {
    /* post请求，提交到categories，req.body可能就是this.model，提交完就跳转到list界面 */
    // axios的baseURL: 'http://localhost:3000/admin/api'

    async save() {
      let res 
      if(this.id) {
        res = await this.$http.put(`categories/${this.id}`, this.model)
      }else {
        res = await this.$http.post('categories', this.model)
      }
      this.$router.push('/categories/list')
      this.$message({
        type: 'success',
        message: '保存成功'
      })
    },
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`categories/${this.id}`)
      this.model = res.data
    }
  },
```

### 5. 删除分类

#### 5.1 初始化

CategoryList.vue

增加一个删除按钮，加上remove方法

```html
<el-table-column
        fixed="right"
        label="操作"
        width="180">
        <!-- scope.row当前行的文档 -->
        <template slot-scope="scope">
          <el-button type="primary"
                @click="$router.push(`/categories/edit/${scope.row._id}`)" 
                size="small">编辑</el-button>
          <el-button type="primary"
                @click="remove(scope.row)" 
                size="small">删除</el-button>
        </template>
      </el-table-column>     
```

#### 5.2 后台删除接口

routes > admin > index.js

```js
// 删除文章的接口
router.delete('/categories/:id', async (req, res) => {
    // 第一个参数是id
    await Category.findByIdAndDelete(req.params.id)
    res.send({
        success: true
    })
})
```

#### 5.3 前端请求删除

CategoryList.vue

删除前有一个提示框，提示是否缺人删除

```js
// 删除方法
async remove(row) { 
    // 删除的时候把类名写出来
    this.$confirm(`是否确定要删除该分类?"${row.name}"`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
    })
        .then(async () => {
        const res = await this.$http.delete(`categories/${row._id}`)
        this.$message({
            type: 'success',
            message: '删除成功!'
        });
        // 删完之后要重新获取以下数据，不然页面不会变化
        this.fetch()
    })
}
```

### 6. 子分类（难点）

#### 6.1 初始化

CategoryEdit.vue

表单中新增了一个上级分类的下拉框

```html
<el-form label-width="120px" @submit.native.prevent="save">
    <el-form-item label="上级分类">
        <!-- 与数据库中的parent绑定 -->
        <el-select v-model="model.parent">
            <!-- 下拉选项的标签（显示的内容）是文档的名字，真正存的值是id（即便以后改了分类的名称
				也不影响 -->
            <el-option v-for="item in parents" :key="item._id" 
                       :label="item.name" :value="item._id"></el-option>
        </el-select>
    </el-form-item>
    <el-form-item label="名称">
        <!-- 双向绑定数据，model指文档 -->
        <el-input v-model="model.name"></el-input>
    </el-form-item>
    <el-form-item>
        <el-button type="primary" native-type="submit">保存</el-button>
    </el-form-item>
</el-form>
```

#### 6.2 请求父级分类

data中新增parents数组，表示包含选项的文档

methods中新增fetchParents方法，为了简便，就直接请求了categories接口，返回所有的分类

created中，组件创立就要去请求

```js
data() {
    return {
      model: {},
      parents: []
    }
  },
  methods: {
    /* post请求，提交到categories，req.body可能就是this.model，提交完就跳转到list界面 */
    // axios的baseURL: 'http://localhost:3000/admin/api'

    async save() {
      let res 
      if(this.id) {
        res = await this.$http.put(`categories/${this.id}`, this.model)
      }else {
        res = await this.$http.post('categories', this.model)
      }
      this.$router.push('/categories/list')
      this.$message({
        type: 'success',
        message: '保存成功'
      })
    },
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`categories/${this.id}`)
      this.model = res.data   
    },
    // 获取父级分类的名称
    async fetchParents() {
      const res = await this.$http.get(`categories`)
      this.parents = res.data
    }
  },
  created() {
    // 有id的时候就去获取
    this.id && this.fetch()
    this.fetchParents()
  }
```

#### 6.3 修改数据库模型

```js
// 定义Category的模型，数据库中会变成复数
const mongoose = require('mongoose')

const schema = new mongoose.Schema({
  name: { type: String },
  // 类型是mongoose里的id类型，ref：关联着Category这个模型，也就是它本身
  // 找当前分类的父级分类，就从Category里面找id和parent的type值相同的
  parent: { type: mongoose.SchemaTypes.ObjectId, ref: 'Category'}
})

module.exports = mongoose.model('Category', schema)
```

#### 6.4 修改列表

CategoryList.vue

列表中新增上级分类这一列，值是数据库中的parent

```html
<el-table-column prop="_id" label="ID" width="230">
</el-table-column>
<el-table-column prop="parent" label="上级分类">
</el-table-column>
<el-table-column prop="name" label="分类名称">
</el-table-column>
...
```

上级分类的保存：下拉菜单选项的值是id，select关联着model.parent，所以提交的时候，数据库里保存了parent字段，值为选中项的id

上级分类的读取：prop=parent，从文档中读parent字段

现在上级分类就显示的是parent字段的id

#### 6.5 显示上级分类的名称

修改后台接口

routes > admin > index.js

查询时，要对parent特殊处理

```js
// 分类列表的接口
router.get('/categories', async (req, res) => {
    /* 关联查询 */
    // parent字段包含type和ref（关联字段），加上populate方法之后，
    // 就会在关联的集合（Category）中查询和parent的type值id相同的文档，
    // parent字段的值就会变成这个文档，没有parent字段的其他文档没有影响
    const items = await Category.find().populate('parent').limit(10)
    res.send(items)
})
```

CategoryList.vue

前端显示的值也要修改

```html
<!-- parent是字段，字段值是一个文档 -->
<el-table-column prop="parent.name" label="上级分类">
</el-table-column>
```

### 7. 通用的CRUD (难点)

#### 7.1 通用性

> 1. 删掉接口中的categories，在路由中间件后面加上动态参数/:resource，以匹配各种接口
> 	还加上了rest前缀（前端请求的时候需要对应修改），避免对其他接口造成影响
> 2. 子路由需要合并参数，不然req拿不到前缀的参数
> 3. 引入接口（resource）对应的模型，而不只是Category
> 4. 转换模型格式，将小写复数的resource转换成大写单数的模型
>     npm i inflection: 单复数转换之类的库
> 5. 使用中间件，负责找到相应的库，而不是每个接口都写一份，中间件函数务必要写next()
>   

```js
// 导出一个函数，给server > index.js使用
// app是个形参，将会传过来express的实例
module.exports = app => {
  const express = require('express')
  // 子路由
  const router = express.Router({
    // resource定义在路由中间件那里，要在下面的具体接口中使用resource
    // 需要合并参数，父子路由的参数合并，让子路由(router)能访问到
    mergeParams: true
  })
  

  // 新建resource（分类）的接口
  router.post('/', async (req, res) => {
    // 根据req.body创建文档，并文档传给客户端
    const model = await req.Model.create(req.body)
    res.send(model)
  })
  // 编辑resource（文章）的接口
  router.put('/:id', async (req, res) => {
    // 第一个参数是id，第二个参数是更新的内容
    const model = await req.Model.findByIdAndUpdate(req.params.id, req.body)
    res.send(model)
  })

  // 删除resource（文章）的接口
  router.delete('/:id', async (req, res) => {
    // 第一个参数是id，第二个参数是更新的内容
    await req.Model.findByIdAndDelete(req.params.id, req.body)
    res.send({
      success: true
    })
  })

  // resource（文章）列表的接口
  router.get('/', async (req, res) => {
    /* 关联查询 */
    // parent字段包含type和ref（关联字段），加上populate方法之后，
    // 就会在关联的集合（req.Model）中查询和parent的type值id相同的文档，
    // parent字段的值就会变成这个文档，没有parent字段的其他文档没有影响
    const items = await req.Model.find().populate('parent').limit(10)
    res.send(items)
  })

  // 获取详情页的数据
  router.get('/:id', async (req, res) => {
    const model = await req.Model.findById(req.params.id)
    res.send(model)
  })
  
  // 通用的接口，将都变成动态的resource,给通用接口加上前缀，防止影响其他接口
  // 中间件一：将/admin/api/rest/:resource路径加到router请求的路径之前
  // 中间件二：根据每次请求的resource，将对应的模型挂载到req上
  app.use('/admin/api/rest/:resource', async (req, res, next) => {
    // 小写复数（req.params.resource）转大写单数（对应的库）
    const modelName = require('inflection').classify(req.params.resource)
    // 引入相应的模型，防止其他块访问不到，挂载到req上
    req.Model = require(`../../models/${modelName}`)
    // 中间件函数一定要next()
    next()
  },router)
}
```

#### 7.2 扩展性

需要考虑可能只有categories这个接口，需要有parent字段

```js
// resource（文章）列表的接口
router.get('/', async (req, res) => {
    // 不是每个模型都有parent字段，所以需要判断
    const queryOptions = {}
    // 模型名称是Category，猜测会把populate('parent')代替setOptions()这一段
    if(req.Model.modelName === 'Category') {
        queryOptions.populate = 'parent'
    }
    const items = await req.Model.find().setOptions(queryOptions).limit(10)
    res.send(items)
}) 
```

## 三. 装备管理

### 1. 新建物品

#### 1.1 初始化

在Main.vue中，左侧导航栏新增了两个导航项

```html
<el-menu-item-group>
    <template slot="title">物品</template>
    <el-menu-item index="/items/create">新建物品</el-menu-item>
    <el-menu-item index="/items/list">物品列表</el-menu-item>
</el-menu-item-group>
```

复制CategoryEdit，CategoryList，重命名为ItemEdit，ItemList，加入路由

admin > router > index.js

```js
{path: '/items/create', component: ItemEdit},
{path: '/items/edit/:id', component: ItemEdit, props: true},
{path: '/items/list', component: ItemList},
```

在ItemEdit中

categories相关改成items，parents相关删掉，增加一个图标表单

```html
<template>
  <div class="category-edit">
    <h1>{{id  ? '编辑' : '新建'}}物品</h1>
    <!-- 点击保存时，执行save方法，.native监听原生组件，.prevent阻止表单默认行为，
          不会跳转页面 -->
    <el-form label-width="120px" @submit.native.prevent="save">
      
      <el-form-item label="名称">
        <!-- 双向绑定数据，model指文档 -->
        <el-input v-model="model.name"></el-input>
      </el-form-item>
      <el-form-item label="图标">
        <!-- 双向绑定数据，model指文档 -->
        <el-input v-model="model.icon"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" native-type="submit">保存</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  // 可以获得路由的params参数
  props: {
    id: {}
  },
  data() {
    return {
      model: {},
    }
  },
  methods: {
    /* post请求，提交到items，req.body可能就是this.model，提交完就跳转到list界面 */
    // axios的baseURL: 'http://localhost:3000/admin/api'

    async save() {
      let res 
      if(this.id) {
        res = await this.$http.put(`/rest/items/${this.id}`, this.model)
      }else {
        res = await this.$http.post('/rest/items', this.model)
      }
      this.$router.push('/items/list')
      this.$message({
        type: 'success',
        message: '保存成功'
      })
    },
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`/rest/items/${this.id}`)
      this.model = res.data   
    },
    
  },
  created() {
    // 有id的时候就去获取
    this.id && this.fetch()
  }
  
}
</script>  

```

#### 1.2 增加模型

写的是通用的增删改查，接口逻辑不用改，但是每个接口都有与路径对应的模型，所以要新增Item模型，将item相关的东西，加入Item集合

server > models > Item.js

```js
const mongoose = require('mongoose')

const schema = mongoose.Schema({
  name: { type: String },
  // 只保存图片地址
  icon: { type: String }
})

module.exports = mongoose.model('Item', schema)
```

#### 1.3 上传图片

##### 1.3.1 初始化

ItemEdit.vue

把之前图标的输入框换成了element中的upload组件

```html
<el-form-item label="图标">
    <el-upload
               class="avatar-uploader"
               action="https://jsonplaceholder.typicode.com/posts/"
               :show-file-list="false"
               :on-success="handleAvatarSuccess"
               :before-upload="beforeAvatarUpload">
        <!-- 图片地址绑定数据库中的icon -->
        <img v-if="model.icon" :src="model.icon" class="avatar">
        <!-- 上传图标，有图片就显示图片，没图片就上传 -->
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
    </el-upload>
</el-form-item>
```

加上element中的样式

```css
<style>
  .avatar-uploader .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .avatar-uploader .el-upload:hover {
    border-color: #409EFF;
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 178px;
    height: 178px;
    line-height: 178px;
    text-align: center;
  }
  .avatar {
    width: 178px;
    height: 178px;
    display: block;
  }
</style>

```

现在显示了上传的样式

##### 1.3.2 修改

```html
<el-form-item label="图标">
    <!-- 修改了action：提交的地址 -->
    <!-- 修改了on-success：成功的回调 -->
    <!-- 删掉了上传前的回调，简便处理 -->
    <el-upload
               class="avatar-uploader"
               :action="$http.defaults.baseURL + '/upload'"
               :show-file-list="false"
               :on-success="afterUpload"
               >
        <!-- 图片地址绑定数据库中的icon -->
        <img v-if="model.icon" :src="model.icon" class="avatar">
        <!-- 上传图标，有图片就显示图片，没图片就上传 -->
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
    </el-upload>
</el-form-item>
```

##### 1.3.3 文件上传

```
server目录的终端：npm i multer：处理上传文件数据的中间件
```

express本身不能处理文件上传，所以需要multer中间件

server > routes > admin > index.js

把文件上传到了server下的uploads

```js
// 处理上传文件数据的中间件：multer
const multer = require('multer')
// dest: 要上传的地址，server下的uploads目录，__dirname:当前文件所在文件夹的绝对路径
const upload = multer({dest: __dirname + '/../../uploads'}) 
// upload.single('file'): 上传单个文件，字段名为file，上传时前端提交表单数据的就是file
// multer中间件允许这个接口可以接收文件上传，并且把上传后的文件信息挂载到req.file
// req.file包含文件路径大小等信息，express本身没有req.file
app.post('/admin/api/upload', upload.single('file'),async(req, res) => {
    const file = req.file
    res.send(file)
})
```

##### 1.3.4 开放uploads

静态文件托管

server > index.js

现在可以通过http://localhost:3000/uploads + 文件名访问uploads里的资源了

```js
// 静态文件托管
app.use('/uploads', express.static(__dirname + '/uploads'))
```

##### 1.3.5 传递url

server > routes > admin > index.js

把图片地址挂载到file的url中

```js
// 处理上传文件数据的中间件：multer
  const multer = require('multer')
  // dest: 要上传的地址，server下的uploads目录，__dirname:当前文件所在文件夹的绝对路径
  const upload = multer({dest: __dirname + '/../../uploads'}) 
  // upload.single('file'): 上传单个文件，字段名为file，上传时前端提交表单数据的就是file
  // multer中间件允许这个接口可以接收文件上传，并且把上传后的文件信息挂载到req.file
  // req.file包含文件路径大小等信息，express本身没有req.file
  app.post('/admin/api/upload', upload.single('file'),async(req, res) => {
    const file = req.file
    // filename就是保存在uploads中的文件名，给file增加url属性，就是图片的地址
    file.url = `http://localhost:3000/uploads/${file.filename}`
    res.send(file)
  })
```

##### 1.3.6 图片展示

应该是element内部操作，成功的回调函数，接收到的参数就是响应res

```js
// 图片上传成功的回调，上文中图片的地址绑定了this.model.icon
afterUpload(res) {
    // res.url就是图片地址
    // this.model.icon = res.url
    // vue中的响应式实现，参数为：对象，属性，属性值
    this.$set(this.model, 'icon', res.url)
},
```

##### 1.3.7 修改样式

```css
/* 上传图标的加号，刷新后会到顶部去，手动调整使其居中 */
.el-icon-plus:before {
    height: 30px;
    content: "\e6d9";
    width: 30px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```

### 2. 物品列表

#### 2.1 初始化

从CategoryList.vue复制，重命名为ItemList.vue

把文件中所有categories相关改成items，删掉了上级分类

路由在新建物品处已经加好了，增加了图标，删掉了父级分类，改了一些文字

```html
<template>
  <div class="category-list">
    <h1>物品列表</h1>
    <!-- 表格数据items，prop大概是items里对象的属性 -->
    <el-table :data="items">       
      <el-table-column prop="_id" label="ID" width="230"></el-table-column>
      <el-table-column prop="name" label="物品名称"></el-table-column>
      <el-table-column prop="icon" label="图标">
        <!-- table的自定义字段，在里面可以自由发挥,scope.row拿到就是这一行的文档 -->
         <template slot-scope="scope">
           <img :src="scope.row.icon" alt="" style="height:3rem">
         </template>
      </el-table-column>
      <el-table-column
        fixed="right"
        label="操作"
        width="180">
        <!-- scope.row当前行的文档 -->
        <template slot-scope="scope">
          <el-button type="primary"
                @click="$router.push(`/items/edit/${scope.row._id}`)" 
                size="small">编辑</el-button>
          <el-button type="primary"
                @click="remove(scope.row)" 
                size="small">删除</el-button>
        </template>
      </el-table-column>       
    </el-table>
  </div>
</template>


<script>
export default {
  data() {
    return {
      items: []
    }
  },
  methods: {
    async fetch() {
      const res = await this.$http.get('/rest/items')
      // res.data才是数据
      this.items = res.data
    },

    // 删除方法
    async remove(row) {      
      this.$confirm(`是否确定要删除该分类?"${row.name}"`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      })
      .then(async () => {
        const res = await this.$http.delete(`/rest/items/${row._id}`)
        this.$message({
          type: 'success',
          message: '删除成功!'
        });
        // 删完之后要重新获取以下数据，不然页面不会变化
        this.fetch()
      })
    }
  },
  created() {
    this.fetch()
  }
}
</script>
```

## 四. 英雄管理

### 1. 初始化

admin > views > Main.vue

左侧菜单新增了英雄的导航部分

```html
<el-menu-item-group>
    <template slot="title">英雄</template>
    <el-menu-item index="/heros/create">新建英雄</el-menu-item>
    <el-menu-item index="/heros/list">英雄列表</el-menu-item>
</el-menu-item-group>          
```

复制ItemEdit，ItemList，重命名为HeroList，HeroEdit

router > index.js中加上对应路由

```js
{path: '/heros/create', component: HeroEdit},
{path: '/heros/edit/:id', component: HeroEdit, props: true},
{path: '/heros/list', component: HeroList},
```

修改item相关为hero相关，路由 标题 图标变头像等

HeroEdit.vue

页面上的每一项都是一个el-form-item

```html
<template>
  <div class="category-edit">
    <h1>{{id  ? '编辑' : '新建'}}英雄</h1>
    <!-- 点击保存时，执行save方法，.native监听原生组件，.prevent阻止表单默认行为，
          不会跳转页面 -->
    <el-form label-width="120px" @submit.native.prevent="save">
      
      <el-form-item label="名称">
        <!-- 双向绑定数据，model指文档 -->
        <el-input v-model="model.name"></el-input>
      </el-form-item>
      <el-form-item label="头像">
        <!-- 修改了action：提交的地址 -->
        <!-- 修改了on-success：成功的回调 -->
        <!-- 删掉了上传前的回调，简便处理 -->
        <el-upload
          class="avatar-uploader"
          :action="$http.defaults.baseURL + '/upload'"
          :show-file-list="false"
          :on-success="afterUpload"
          >
          <!-- 图片地址绑定数据库中的avatar -->
          <img v-if="model.avatar" :src="model.avatar" class="avatar">
          <!-- 上传图标，有图片就显示图片，没图片就上传 -->
          <i v-else class="el-icon-plus avatar-uploader-icon"></i>
        </el-upload>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" native-type="submit">保存</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  // 可以获得路由的params参数
  props: {
    id: {}
  },
  data() {
    return {
      model: {
        name: '',
        avatar: ''
      },
    }
  },
  methods: {
    /* post请求，提交到heros，req.body可能就是this.model，提交完就跳转到list界面 */
    // axios的baseURL: 'http://localhost:3000/admin/api'
    // 图片上传成功的回调
    afterUpload(res) {
      // 属性存在的时候，这个就是响应式的
      this.model.avatar = res.url
    },
    async save() {
      let res 
      if(this.id) {
        res = await this.$http.put(`/rest/heros/${this.id}`, this.model)
      }else {
        res = await this.$http.post('/rest/heros', this.model)
      }
      this.$router.push('/heros/list')
      this.$message({
        type: 'success',
        message: '保存成功'
      })
    },
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`/rest/heros/${this.id}`)
      this.model = res.data   
    },
    
  },
  created() {
    // 有id的时候就去获取
    this.id && this.fetch()
  }
  
}
</script>


<style>
  .avatar-uploader .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .avatar-uploader .el-upload:hover {
    border-color: #409EFF;
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 178px;
    height: 178px;
    line-height: 178px;
    text-align: center;
  }
  .avatar {
    width: 178px;
    height: 178px;
    display: block;
  }
  /* 上传图标的加号，刷新后会到顶部去，手动调整使其居中 */
  .el-icon-plus:before {
    height: 30px;
    content: "\e6d9";
    width: 30px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
</style>

```

HeroList.vue

```html
<template>
  <div class="category-list">
    <h1>英雄列表</h1>
    <!-- 表格数据items，prop大概是heros里对象的属性 -->
    <el-table :data="items">       
      <el-table-column prop="_id" label="ID" width="230"></el-table-column>
      <el-table-column prop="name" label="英雄名称"></el-table-column>
      <el-table-column prop="avatar" label="头像">
        <!-- table的自定义字段，在里面可以自由发挥,scope.row拿到就是这一行的文档 -->
         <template slot-scope="scope">
           <img :src="scope.row.avatar" alt="" style="height:3rem">
         </template>
      </el-table-column>
      <el-table-column
        fixed="right"
        label="操作"
        width="180">
        <!-- scope.row当前行的文档 -->
        <template slot-scope="scope">
          <el-button type="primary"
                @click="$router.push(`/heros/edit/${scope.row._id}`)" 
                size="small">编辑</el-button>
          <el-button type="primary"
                @click="remove(scope.row)" 
                size="small">删除</el-button>
        </template>
      </el-table-column>       
    </el-table>
  </div>
</template>


<script>
export default {
  data() {
    return {
      // 表示数据，而不是物品
      items: []
    }
  },
  methods: {
    async fetch() {
      const res = await this.$http.get('/rest/heros')
      // res.data才是数据
      this.items = res.data
    },

    // 删除方法
    async remove(row) {      
      this.$confirm(`是否确定要删除该分类?"${row.name}"`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      })
      .then(async () => {
        const res = await this.$http.delete(`/rest/heros/${row._id}`)
        this.$message({
          type: 'success',
          message: '删除成功!'
        });
        // 删完之后要重新获取以下数据，不然页面不会变化
        this.fetch()
      })
    }
  },
  created() {
    this.fetch()
  }
}
</script>
```

### 2. 增加模型

复制Item.js，重命名为Hero.js，修改item，icon为Hero，avatar

```js
const mongoose = require('mongoose')

const schema = mongoose.Schema({
  name: { type: String },
  // 只保存图片地址
  avatar: { type: String }
})

module.exports = mongoose.model('Hero', schema)
```

### 3. 修改模型

这个模型比较复杂，每一个字段都对应着前端英雄界面的内容

```js
const mongoose = require('mongoose')

const schema = mongoose.Schema({
  name: { type: String },
  // 只保存图片地址
  avatar: { type: String },
  // 英雄的称号，比如：后羿称号半神之弓
  title: { type: String },
  // 分类，每一个英雄都有自己的分类，战士，法师等
  // 关联字段，category字段的值会是Category集合中id相同的文档
  // 新知识：一个英雄有多个分类，使用数组，这个字段会关联多个文档
  // 有多个分类就会将多个分类加进来
  categories: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Category'}],
  // 新知识：复合类型，英雄有难度，技能，攻击，生存四项评分，对象中嵌套对象
  // scores这个字段中包含四个字段
  scores: { 
    difficult: {type: Number},
    skills: {type: Number},
    attack: {type: Number},
    survive: {type: Number},
  },
  // 技能有多个，而且每个技能也有多个指标，名称图标简介等
  skills: [{
    icon: { type: String },
    name: { type: String },
    description: { type: String },
    tips: { type: String }
  }],
  // 顺风/逆风出装，多个装备用数组，每个装备都关联着装备模型，数据到时候到Item中去找
  items1: [{type: mongoose.SchemaTypes.ObjectId, ref: 'Item'}],
  items2: [{type: mongoose.SchemaTypes.ObjectId, ref: 'Item'}],
  // 使用技巧
  usageTips: { type: String },
  // 对抗技巧
  battleTips: { type: String },
  // 团战技巧
  teamsTips: { type: String },
  // 搭档，搭档这里有英雄和搭档的理由
  partners: [{
    hero: { type: mongoose.SchemaTypes.ObjectId, ref: 'Hero' },
    description: { type: String }
  }]
})

module.exports = mongoose.model('Hero', schema)
```

### 4. 修改编辑英雄

编辑或者新建英雄要多很多选项，不只是名字和头像

#### 4.1 称号

新增了称号，绑定model的不同值

```html
<el-form-item label="名称">
    <el-input v-model="model.name"></el-input>
</el-form-item>
<el-form-item label="称号">
    <el-input v-model="model.title"></el-input>
</el-form-item>
```

#### 4.2 分类

新增分类，下拉菜单

```html
<el-form-item label="类型">
    <el-select v-model="model.categories" multiple>
    <el-option v-for="item of categories"
    	:label="item.name" :value="item._id" :key="item._id"></el-option>
    </el-select>
</el-form-item>
```

data中加上categories数组，methods中加上fetchCategories方法，并且在组件创建的时候去获取数据

```js
data() {
    return {
      categories: [],
      model: {
        name: '',
        avatar: ''
      },
    }
  },
  methods: {
    /* post请求，提交到heros，req.body可能就是this.model，提交完就跳转到list界面 */
    // axios的baseURL: 'http://localhost:3000/admin/api'
    // 图片上传成功的回调
    afterUpload(res) {
      // 属性存在的时候，这个就是响应式的
      this.model.avatar = res.url
    },
    async save() {
      let res 
      if(this.id) {
        res = await this.$http.put(`/rest/heros/${this.id}`, this.model)
      }else {
        res = await this.$http.post('/rest/heros', this.model)
      }
      this.$router.push('/heros/list')
      this.$message({
        type: 'success',
        message: '保存成功'
      })
    },
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`/rest/heros/${this.id}`)
      this.model = res.data   
    },
    // 获取分类信息
    async fetchCategories() {
      const res = await this.$http.get(`/rest/categories`)
      this.categories = res.data   
    },
    
  },
  created() {
    // 有id的时候就去获取
    this.id && this.fetch()
    this.id && this.fetchCategories()
  }
  
```

#### 4.3 评分

写一个，复制四分，修改绑定的属性值

```html
<!-- 四组评分，都是scores这个字段的字段 -->
<el-form-item label="难度">
    <!-- data中的model必须初始化scores属性为{}，不然这里会报错 -->
    <el-rate :max="9" show-score style="margin-top: 0.6rem" 
             v-model="model.scores.difficult"></el-rate>
</el-form-item>
<el-form-item label="技能">
    <el-rate :max="9" show-score style="margin-top: 0.6rem" 
             v-model="model.scores.skills"></el-rate>
</el-form-item>
<el-form-item label="攻击">
    <el-rate :max="9" show-score style="margin-top: 0.6rem" 
             v-model="model.scores.attack"></el-rate>
</el-form-item>
<el-form-item label="生存">
    <el-rate :max="9" show-score style="margin-top: 0.6rem" 
             v-model="model.scores.survive"></el-rate>
</el-form-item>
```

由覆盖赋值，变为合并赋值，以免有些值不完善时会报错，覆盖了前面初始化的空值，后面由没有传这个值

```js
// 获取详情页数据
async fetch() {
    const res = await this.$http.get(`/rest/heros/${this.id}`)
    // 覆盖赋值
    // this.model = res.data   
    // 合并对象，属性为三者之和，属性值后出现的优先
    this.model = Object.assign({}, this.model, res.data)
},
```

#### 4.4 顺风出装

选项来自装备列表，所以需要获取数据

```html
<el-form-item label="顺风出装">
    <el-select v-model="model.items1" multiple>
        <el-option v-for="item of items"
                   :label="item.name" :value="item._id" :key="item._id"></el-option>
    </el-select>
</el-form-item>
<!-- 绑定的字段不一样，但是选项一样，都是装备列表 -->
<el-form-item label="逆风出装">
    <el-select v-model="model.items2" multiple>
        <el-option v-for="item of items"
                   :label="item.name" :value="item._id" :key="item._id"></el-option>
    </el-select>
</el-form-item>
```

```js
// 获取装备数据
async fetchItems() {
    const res = await this.$http.get(`/rest/items`)
    this.items = res.data   
},
```

```js
created() {
    // 有id的时候就去获取
    this.id && this.fetch()
    this.id && this.fetchCategories()
    this.id && this.fetchItems()
  }
```

#### 4.5 使用技巧

```html
<el-form-item label="使用技巧">
    <el-input type="textarea" v-model="model.usageTips"></el-input>
</el-form-item>
<el-form-item label="对抗技巧">
    <el-input type="textarea" v-model="model.battleTips"></el-input>
</el-form-item>
<el-form-item label="团战思路">
    <el-input type="textarea" v-model="model.teamTips"></el-input>
</el-form-item>
```

HeroList里新增了英雄称号这一列

```html
<el-table-column prop="title" label="英雄称号"></el-table-column>
```

#### 4.6 编辑分页

因为英雄的编辑内容太多了，所以使用el-tabs分页，基本信息一页，技能编辑一页

就是把之前写的都放在一个el-tab-pane里面了

```html
<!-- el-tabs相当于给编辑部分分页，因为太多了，value默认选中和name值相同的 -->
<el-tabs value="skills" type="border-card">
    <!-- 点击基本信息，下面这部分就出来了 -->
    <el-tab-pane label="基本信息" name="">
        <el-form-item label="名称">
            <el-input v-model="model.name"></el-input>
        </el-form-item>
        <el-form-item label="称号">
            <el-input v-model="model.title"></el-input>
        </el-form-item>
        <el-form-item label="头像">
            <!-- 修改了action：提交的地址 -->
            <!-- 修改了on-success：成功的回调 -->
            <!-- 删掉了上传前的回调，简便处理 -->
            <el-upload
                       class="avatar-uploader"
                       :action="$http.defaults.baseURL + '/upload'"
                       :show-file-list="false"
                       :on-success="afterUpload"
                       >
                <!-- 图片地址绑定数据库中的avatar -->
                <img v-if="model.avatar" :src="model.avatar" class="avatar">
                <!-- 上传图标，有图片就显示图片，没图片就上传 -->
                <i v-else class="el-icon-plus avatar-uploader-icon"></i>
            </el-upload>
        </el-form-item>
        <el-form-item label="类型">
            <el-select v-model="model.categories" multiple>
                <el-option v-for="item of categories"
                           :label="item.name" :value="item._id" :key="item._id"></el-option>
            </el-select>
        </el-form-item>
        <!-- 四组评分，都是scores这个字段的字段 -->
        <el-form-item label="难度">
            <!-- data中的model必须初始化scores属性为{}，不然这里会报错 -->
            <el-rate :max="9" show-score style="margin-top: 0.6rem" 
                     v-model="model.scores.difficult"></el-rate>
        </el-form-item>
        <el-form-item label="技能">
            <el-rate :max="9" show-score style="margin-top: 0.6rem" 
                     v-model="model.scores.skills"></el-rate>
        </el-form-item>
        <el-form-item label="攻击">
            <el-rate :max="9" show-score style="margin-top: 0.6rem" 
                     v-model="model.scores.attack"></el-rate>
        </el-form-item>
        <el-form-item label="生存">
            <el-rate :max="9" show-score style="margin-top: 0.6rem" 
                     v-model="model.scores.survive"></el-rate>
        </el-form-item>
        <el-form-item label="顺风出装">
            <el-select v-model="model.items1" multiple>
                <el-option v-for="item of items"
                           :label="item.name" :value="item._id" :key="item._id"></el-option>
            </el-select>
        </el-form-item>
        <!-- 绑定的字段不一样，但是选项一样，都是装备列表 -->
        <el-form-item label="逆风出装">
            <el-select v-model="model.items2" multiple>
                <el-option v-for="item of items"
                           :label="item.name" :value="item._id" :key="item._id"></el-option>
            </el-select>
        </el-form-item>
        <el-form-item label="使用技巧">
            <el-input type="textarea" v-model="model.usageTips"></el-input>
        </el-form-item>
        <el-form-item label="对抗技巧">
            <el-input type="textarea" v-model="model.battleTips"></el-input>
        </el-form-item>
        <el-form-item label="团战思路">
            <el-input type="textarea" v-model="model.teamTips"></el-input>
        </el-form-item>
    </el-tab-pane>
</el-tabs>
```

#### 4.7. 技能编辑

每个技能有四项内容，点击按钮就弹出一个技能编辑，一行最多两个

```html
<el-tab-pane label="技能" name="skills">
    <!-- 每次点击给model.skills里添加一个对象 -->
    <!-- <el-button type="text" @click="model.skills.push({})"> 
		<i class="el-icon-plus"></i> 添加技能</el-button> -->
    <el-button type="primary" size="small" @click="model.skills.push({})"> 
        添加技能</el-button>
    <!-- 响应式布局，点击按钮，就会多一列，并且每一列会缩小 -->
    <el-row type="flex" style="flex-wrap: wrap">
        <!-- 一行有两个技能，随着添加按钮的点击，el-col循环展示 -->
        <!-- md可能是中等尺寸屏幕的意思 -->
        <el-col :md="12" v-for="(item, i) in model.skills" :key="i">
            <!-- 每一个技能有四项内容，所以有四个form-item -->
            <el-form-item label="名称">
                <!-- 每一个输入框绑定的值，对应后端模型中skills字段的值 -->
                <el-input v-model="item.name"></el-input>
            </el-form-item>
            <el-form-item label="图标">
                <el-upload
                           class="avatar-uploader"
                           :action="$http.defaults.baseURL + '/upload'"
                           :show-file-list="false"
                           :on-success="afterUpload"
                           >
                    <!-- 图片地址绑定数据库中的avatar -->
                    <img v-if="item.icon" :src="item.icon" class="avatar">
                    <!-- 上传图标，有图片就显示图片，没图片就上传 -->
                    <i v-else class="el-icon-plus avatar-uploader-icon"></i>
                </el-upload>
            </el-form-item>
            <el-form-item label="描述" >
                <el-input type="textarea" v-model="item.description"></el-input>
            </el-form-item>
            <el-form-item label="小提示" >
                <el-input type="textarea" v-model="item.tips"></el-input>
            </el-form-item>
        </el-col>
    </el-row>
</el-tab-pane>
```

#### 4.8 修改上传图片

修改了on-success的回调函数，之前是model.icon赋值，现在是item.icon赋值，

item指一个技能，model是物品模型

```html
<el-form-item label="图标">
    <el-upload
               class="avatar-uploader"
               :action="$http.defaults.baseURL + '/upload'"
               :show-file-list="false"
               :on-success="res => $set(item, 'icon', res.url)"
               >
        <!-- item指技能，res就是返回的结果，res.url是图片的地址 -->
        <img v-if="item.icon" :src="item.icon" class="avatar">
        <!-- 上传图标，有图片就显示图片，没图片就上传 -->
        <i v-else class="el-icon-plus avatar-uploader-icon"></i>
    </el-upload>
</el-form-item>
```

修改了图片的大小，改成了5rem

```css
.avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 5rem;
    height: 5rem;
    line-height: 5rem;
    text-align: center;
}
.avatar {
    width: 5rem;
    height: 5rem;
    display: block;
}
```

#### 4.9 删除技能

因为删掉之后，还会点保存，保存就会将删除后的结果发给服务器，所以删除本身不需要请求接口

```html
<el-form-item>
    <el-button size="small" type="danger" 
			@click="model.skills.splice(i, 1)">删除</el-button>
</el-form-item>
```

## 五. 文章管理

### 1. 初始化

和前面一样，

* 在Main.vue左侧导航区加上文章的导航
* 复制CategoryEdit.vue CategoryList.vue，重命名为ArticleEdit，ArticleList
* 在路由中加入文章的路由

### 2. 修改编辑文章

接口请求地址，标题，下拉菜单绑定的字段，下拉选项遍历的数组发生了变化

```html
<template>
  <div class="category-edit">
    <h1>{{id  ? '编辑' : '新建'}}文章</h1>
    <!-- 点击保存时，执行save方法，.native监听原生组件，.prevent阻止表单默认行为，
          不会跳转页面 -->
    <el-form label-width="120px" @submit.native.prevent="save">
      <el-form-item label="所属分类">
        <!-- 文章的下拉框绑定categories字段，一篇文章可能有多个分类 -->
        <el-select v-model="model.categories" multiple>
          <!-- 下拉选项的标签（显示的内容）是文档的名字，真正存的值是id -->
          <el-option v-for="item in categories" :key="item._id" 
          :label="item.name" :value="item._id"></el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="标题">
        <!-- 双向绑定数据，model指文档 -->
        <el-input v-model="model.title"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" native-type="submit">保存</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  // 可以获得路由的params参数
  props: {
    id: {}
  },
  data() {
    return {
      // model.categoires是数据库中，这篇文章的所属分类
      // categories是所有存在的分类
      model: {},
      // 文章的分类
      categories: []
    }
  },
  methods: {
    /* post请求，提交到articles，req.body可能就是this.model，提交完就跳转到list界面 */
    // axios的baseURL: 'http://localhost:3000/admin/api'

    async save() {
      let res 
      if(this.id) {
        res = await this.$http.put(`/rest/articles/${this.id}`, this.model)
      }else {
        res = await this.$http.post('/rest/articles', this.model)
      }
      this.$router.push('/articles/list')
      this.$message({
        type: 'success',
        message: '保存成功'
      })
    },
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`/rest/articles/${this.id}`)
      this.model = res.data   
    },
    // 获取所属分类的名称
    async fetchCategories() {
      const res = await this.$http.get(`/rest/categories`)
      this.categories = res.data
    }
  },
  created() {
    // 有id的时候就去获取
    this.id && this.fetch()
    this.fetchCategories()
  }
  
}
</script>  

```

### 3. 增加文章模型

```js
const mongoose = require('mongoose')

const schema = new mongoose.Schema({
  title: { type: String },
  categories: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Category'}],
  // 文章详情
  body: { type: String },
})

module.exports = mongoose.model('Article', schema)
```

### 4. 富文本编辑器 （难点）

编辑文章界面需要用加上文章详情这一块，文章详情用富文本编辑器

```
npm install --save vue2-editor
```

下载之后，引入到CategoryEdit.vue页面，注册组件

```js
import { VueEditor } from 'vue2-editor'

// 使用VueEditor
components: {
    VueEditor
},
```

加上这个表单项

```html
<el-form-item label="详情">
    <vue-editor v-model="model.body"></vue-editor>
</el-form-item>
```

现在前端就已经出现了富文本编辑器

### 5. 图片上传

```js
https://www.vue2editor.com/examples/#custom-image-handler
```

因为这个富文本编辑器，会将图片变成base64格式存储，嵌在前端页面上，非常大，会导致网络请求变慢，所以改成图片上传

加了一个属性 一个监听方法 

```html
<el-form-item label="详情">
    <vue-editor useCustomImageHandler @imageAdded="handleImageAdded" 
                v-model="model.body"></vue-editor>
</el-form-item>
```

```js
async handleImageAdded(file, Editor, cursorLocation, resetUploader) {
    // 表单数据，将键改为file，和网络请求（浏览器可查看）的Form Data中键名一样
    var formData = new FormData();
    formData.append("file", file);

    const res = await this.$http.post('upload', formData)
    // 大概是光标位置嵌入一张图片
    Editor.insertEmbed(cursorLocation, "image", res.url);
    resetUploader();
},
```

## 六. 广告管理

复制，修改接口地址，配置路由，后端增加模型

暂时不做这部分了

```html
<el-submenu index="2">
          <template slot="title"><i class="el-icon-message"></i>运营管理</template>
          <el-menu-item-group>
            <template slot="title">分类</template>
            <el-menu-item index="/categories/create">新建分类</el-menu-item>
            <el-menu-item index="/categories/list">分类列表</el-menu-item>
          </el-menu-item-group>          
          <el-menu-item-group>
            <template slot="title">物品</template>
            <el-menu-item index="/items/create">新建物品</el-menu-item>
            <el-menu-item index="/items/list">物品列表</el-menu-item>
          </el-menu-item-group>          
          <el-menu-item-group>
            <template slot="title">英雄</template>
            <el-menu-item index="/heros/create">新建英雄</el-menu-item>
            <el-menu-item index="/heros/list">英雄列表</el-menu-item>
          </el-menu-item-group>          
          <el-menu-item-group>
            <template slot="title">文章</template>
            <el-menu-item index="/articles/create">新建文章</el-menu-item>
            <el-menu-item index="/articles/list">文章列表</el-menu-item>
          </el-menu-item-group>                    
        </el-submenu>
```

## 七. 管理员账号管理

### 1. 调整页面

因为左侧导航栏都在内容管理里，太多了，所以把它们分散到三个el-submenu中，分为内容管理，运营管理，系统管理三个下拉菜单

```html
<template>
  <el-container style="height: 100vh; ">
    <!-- 左侧导航 -->
    <el-aside width="200px" style="background-color: rgb(238, 241, 246)">
      <!-- unique-opened：一次只能展开一个, 
            :default-active="$route.path: 默认高亮当前路径的导航 -->
            <!-- :default-opendes如果直接绑定['1'],
            点击第二个的内容，会将第二个菜单收起来，打开第一个菜单，
            绑定了一个变量，变量=['1']，这样就好了，点击谁，谁就是展开的 -->
      <el-menu router :default-openeds="currentIndex" unique-opened 
            :default-active="$route.path">
        <el-submenu index="1">
          <template slot="title"><i class="el-icon-message"></i>内容管理</template>        
          <el-menu-item-group>
            <template slot="title">物品</template>
            <el-menu-item index="/items/create">新建物品</el-menu-item>
            <el-menu-item index="/items/list">物品列表</el-menu-item>
          </el-menu-item-group>          
          <el-menu-item-group>
            <template slot="title">英雄</template>
            <el-menu-item index="/heros/create">新建英雄</el-menu-item>
            <el-menu-item index="/heros/list">英雄列表</el-menu-item>
          </el-menu-item-group>          
          <el-menu-item-group>
            <template slot="title">文章</template>
            <el-menu-item index="/articles/create">新建文章</el-menu-item>
            <el-menu-item index="/articles/list">文章列表</el-menu-item>
          </el-menu-item-group>                    
        </el-submenu>
        <el-submenu index="2">
          <template slot="title"><i class="el-icon-message"></i>运营管理</template>  
          <el-menu-item-group>
            <template slot="title">广告位</template>
            <el-menu-item>新建广告位</el-menu-item>
          <el-menu-item>广告位列表</el-menu-item>
          </el-menu-item-group>                
        </el-submenu>
        <el-submenu index="3">
          <template slot="title"><i class="el-icon-message"></i>系统设置</template>
          <el-menu-item-group>
            <template slot="title">分类</template>
            <el-menu-item index="/categories/create">新建分类</el-menu-item>
            <el-menu-item index="/categories/list">分类列表</el-menu-item>
          </el-menu-item-group>                         
          <el-menu-item-group>
            <template slot="title">管理员</template>
            <el-menu-item index="/admin_users/create">新建管理员</el-menu-item>
            <el-menu-item index="/admin_users/list">管理员列表</el-menu-item>
          </el-menu-item-group>                         
        </el-submenu>
      </el-menu>
    </el-aside>
    
    <el-container>
      <!-- 头部 -->
      <el-header style="text-align: right; font-size: 12px">
        <el-dropdown>
          <i class="el-icon-setting" style="margin-right: 15px"></i>
          <el-dropdown-menu slot="dropdown">
            <el-dropdown-item>查看</el-dropdown-item>
            <el-dropdown-item>新增</el-dropdown-item>
            <el-dropdown-item>删除</el-dropdown-item>
          </el-dropdown-menu>
        </el-dropdown>
        <span>王小虎</span>
      </el-header>
      
      <el-main>
        <!-- 主体内容 -->
        <router-view></router-view>
        
      </el-main>
    </el-container>
  </el-container>
</template>
<style>
  .el-header {
    background-color: #B3C0D1;
    color: #333;
    line-height: 60px;
  }
  
  .el-aside {
    color: #333;
  }
</style>

<script>
  export default {
    data() {
      const item = {
        date: '2016-05-02',
        name: '王小虎',
        address: '上海市普陀区金沙江路 1518 弄'
      };
      return {
        currentIndex: ['1'],
        tableData: Array(20).fill(item)
      }
    }
  };
</script>
```

### 2. 初始化

和之前一样的套路，复制组件，配置路由，修改组件

AdminUserEdit.vue

```html
<template>
  <div class="category-edit">
    <h1>{{id  ? '编辑' : '新建'}}管理员</h1>
    <!-- 点击保存时，执行save方法，.native监听原生组件，.prevent阻止表单默认行为，
          不会跳转页面 -->
    <el-form label-width="120px" @submit.native.prevent="save">
      <el-form-item label="名称">
        <!-- 双向绑定数据，model指文档 -->
        <el-input v-model="model.username"></el-input>
      </el-form-item>
      <el-form-item label="密码">
        <!-- 密码框 -->
        <el-input v-model="model.password" type="password"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" native-type="submit">保存</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  // 可以获得路由的params参数
  props: {
    id: {}
  },
  data() {
    return {
      model: {},
    }
  },
  methods: {
    /* post请求，提交到admin_users，req.body可能就是this.model，提交完就跳转到list界面 */
    // axios的baseURL: 'http://localhost:3000/admin/api'

    async save() {
      let res 
      if(this.id) {
        res = await this.$http.put(`/rest/admin_users/${this.id}`, this.model)
      }else {
        res = await this.$http.post('/rest/admin_users', this.model)
      }
      this.$router.push('/admin_users/list')
      this.$message({
        type: 'success',
        message: '保存成功'
      })
    },
    // 获取详情页数据
    async fetch() {
      const res = await this.$http.get(`/rest/admin_users/${this.id}`)
      this.model = res.data   
    },
  },
  created() {
    // 有id的时候就去获取
    this.id && this.fetch()
  }
  
}
</script>  

```

AdminUserList.vue

```html
<template>
  <div class="category-list">
    <h1>管理员列表</h1>
    <!-- 表格数据items，prop大概是items里对象的属性 -->
    <el-table :data="items">       
      <el-table-column prop="_id" label="ID" width="230"></el-table-column>
      <el-table-column prop="username" label="用户名"></el-table-column>
      <el-table-column
        fixed="right"
        label="操作"
        width="180">
        <!-- scope.row当前行的文档 -->
        <template slot-scope="scope">
          <el-button type="primary"
                @click="$router.push(`/admin_users/edit/${scope.row._id}`)" 
                size="small">编辑</el-button>
          <el-button type="primary"
                @click="remove(scope.row)" 
                size="small">删除</el-button>
        </template>
      </el-table-column>       
    </el-table>
  </div>
</template>


<script>
export default {
  data() {
    return {
      items: []
    }
  },
  methods: {
    async fetch() {
      const res = await this.$http.get('/rest/admin_users')
      // res.data才是数据
      this.items = res.data
    },

    // 删除方法
    async remove(row) {      
      this.$confirm(`是否确定要删除"${row.username}"`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      })
      .then(async () => {
        const res = await this.$http.delete(`/rest/admin_users/${row._id}`)
        this.$message({
          type: 'success',
          message: '删除成功!'
        });
        // 删完之后要重新获取以下数据，不然页面不会变化
        this.fetch()
      })
    }
  },
  created() {
    this.fetch()
  }
}
</script>
```

### 3. 添加模型

或许应该先添加模型，后写组件

```js
// 定义Category的模型，数据库中会变成复数
const mongoose = require('mongoose')

const schema = new mongoose.Schema({
  username: { type: String },
  password: { type: String }
})

module.exports = mongoose.model('AdminUser', schema)
```

### 4. 加密

存储管理员的密码，不能用明文

下载用于加密的库：bcrypt

```
npm i bcrypt
```

修改模型

给密码加密，并且编辑管理员的时候不显示密码

```js
// 定义Category的模型，数据库中会变成复数
const mongoose = require('mongoose')

const schema = new mongoose.Schema({
  username: { type: String },
 
  // set函数，将输入的密码加密之后再存储
  password: { 
    type: String, 
    // select：编辑的时候密码不会显示，这样再次保存的时候，密码就不会二次加密了
    select: false, 
    set(val) {
    // 第一个参数是输入的值，第二个参数是加密等级，应该在10-12比较合理
    	return require('bcrypt').hashSync(val, 12)
      }}
    })

module.exports = mongoose.model('AdminUser', schema)
```

## 八. 登录

### 1. 登录界面初始化

写好静态页面

```html
<template>
  <div class="login-container">
    <el-card header="请先登录" class="login-card">
      <el-form @submit.native.prevent="login">
        <el-form-item label="用户名">
          <el-input v-model="model.username"></el-input>
        </el-form-item>
        <el-form-item label="密码">
          <el-input type="password" v-model="model.password"></el-input>
        </el-form-item>
        <el-form-item>
          <!-- 提交按钮 -->
          <el-button native-type="submit" type="primary">登录</el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </div>
</template>

<script>


export default {
  name: 'Home',
  data() {
    return {
      model: {}
    }
  },
  methods: {
    login() {
      console.log(this.model)
    }
  }
}
</script>

<style>
  .login-card {
    width: 25rem;
    margin: 5rem auto;
  }
</style>

```

### 2. 全局的响应拦截

登录出错的两种情况，都会返回422的状态码，相应拦截也就会弹出错误信息

```js
import axios from 'axios'
import Vue from 'vue'

const http = axios.create({
  baseURL: 'http://localhost:3000/admin/api'
})

// 响应拦截器，所有组件的axios响应都会经过这里
http.interceptors.response.use(res => {
  return res
}, err => {
  // err.response: 响应的数据，响应头，状态码等
  // err.response.data就是send的参数，{message: "用户名不存在"}
  // 如果出错，就弹出错误信息，Vue的原型对象调用$message方法
  if(err.response.data.message) {
    Vue.prototype.$message({
      type: 'error',
      message: err.response.data.message
    })
    return Promise.reject(err)
  }  
})
export default http
```

### 3. 登录的接口

server > index.js

```js
// 给app加上一个属性secret，值为第二个参数，生成token用的，
// 正式的应该放在环境变量中（不知道怎么写）
app.set('secret', 'ertwesdfg6ityuiwqer')
```

判断用户是否存在 > 判断密码是否正确 > 返回token

```js
// 登录的接口
app.post('/admin/api/login', async (req, res) => {
    const { username, password } = req.body
    // 1. 根据用户名找用户
    const AdminUser = require('../../models/AdminUser')
    // 属性和值同名的简写方式
    // .select('+password'): 把隐藏的password取出来
    // +强制取，-排除
    const user = await AdminUser.findOne({username}).select('+password')
    if(!user) {
        return res.status(422).send({
            message: '用户不存在'
        })
    }

    // 2. 校验密码，参数是明文和密文，返回boolean值，true为正确
    const isValid = require('bcrypt').compareSync(password, user.password)
    if(!isValid) {
        return res.status(422).send({
            message: '密码错误',
            password: user.password
        })
    }
    // 3. 返回token  npm i jsonwebtoken
    // app.get(): 只有一个参数，获取属性；多个参数，请求接口
    // sign: 第一个参数是对象，可以包含任何信息，一般用id这类可以唯一标识的信息
    //       第二个参数是密钥，随机的字符串，将来用来验证token的
    //       根据这两个参数就能生成token了
    const jwt = require('jsonwebtoken')
    const token = jwt.sign({id: user._id,}, app.get('secret'))
    res.send({token}) 
})
```

### 4. 前端保存token

Login.vue

```js
methods: {
    async login() {
        const res = await this.$http.post('login', this.model)
        // 把token存在localStorage，永久存储
        localStorage.token = res.data.token
        // 存在sessionStorage中，浏览器关闭就没了
        // sessionStorage.token = res.data.token
        this.$router.push('/')
        // 弹出登录成功
        this.$message({
            type: 'success',
            message: '登录成功'
        })
    }
}
```



### 4. http错误校验 (改进)

引入一个包 http-assert，不用每次都if判断了

```
npm i http-assert
```

在导出函数的顶部，引入http-assert这个包

```js
const express = require('express')
const AdminUser = require('../../models/AdminUser')
// 引入jwt
const jwt = require('jsonwebtoken')
// http错误处理
const assert = require('http-assert')
// 子路由
const router = express.Router({
    // resource定义在路由中间件那里，要在下面的具体接口中使用resource
    // 需要合并参数，父子路由的参数合并，让子路由(router)能访问到
    mergeParams: true
})
```

更改登录接口的验证

把if判断变成assert()函数的判断，assert抛出异常，再让最后的中间件进行错误处理

```js
// 登录的接口
app.post('/admin/api/login', async (req, res) => {
    const { username, password } = req.body
    // 1. 根据用户名找用户，放到上面去了，因为多个地方需要用
    // const AdminUser = require('../../models/AdminUser')
    // 属性和值同名的简写方式
    // .select('+password'): 把隐藏的password取出来
    // +强制取，-排除
    const user = await AdminUser.findOne({username}).select('+password')
    // if(!user) {
    //   return res.status(422).send({
    //     message: '用户不存在'
    //   })
    // }
    // 验证用户是否存在，如果不存在状态码设置为422，抛出错误信息为‘用户不存在’
    // 后面的错误处理函数来捕获异常
    assert(user, 422, '用户不存在')

    // 2. 校验密码，参数是明文和密文，返回boolean值，true为正确
    const isValid = require('bcrypt').compareSync(password, user.password)
    // if(!isValid) {
    //   return res.status(422).send({
    //     message: '密码错误',
    //     password: user.password
    //   })
    // }
    assert(isValid, 422, '密码错误')

    // 3. 返回token  npm i jsonwebtoken
    // app.get(): 只有一个参数，获取属性；多个参数，请求接口
    // sign: 第一个参数是对象，可以包含任何信息，一般用id这类可以唯一标识的信息
    //       第二个参数是密钥，随机的字符串，将来用来验证token的
    //       根据这两个参数就能生成token了
    const token = jwt.sign({id: user._id,}, app.get('secret'))
    res.send({token}) 
})

// 错误处理函数
app.use(async (err, req, res, next) => {
    // statusCode: 错误时的状态码，如果没有状态码就报500错误
    res.status(err.statusCode || 500).send({
        message: err.message
    })
})
```

### 5. 登录校验

#### 5.1 后端验证

把登录的中间件，寻找模型的中间件抽离出来，寻找模型的中间件与登录作用无关，只是写在这了

```js
// 登录校验中间件
const authMiddleware = async (req, res, next) => {   
    // 从请求头中获取token，后端用小写
    // 根据空格分割字符串，第二个才是token
    const token = String(req.headers.authorization || '').split(' ').pop()
    // 验证token存在
    assert(token, 401, '请先登录')
    // 最终会解析出来{id: .....}，也就是用于生成token的东西
    const { id } = jwt.verify(token, app.get('secret'))
    // 验证id存在
    assert(id, 401, '请先登录')
    req.user = await AdminUser.findById(id)
    // 以上三步，token,id,req.user任意一步有问题都应该报错
    assert(req.user, 401, '请先登录')
    await next()
}
```

```js
// 根据请求的路径找到对应模型的中间件
const resourceMiddleware = async (req, res, next) => {
    // 小写复数（req.params.resource）转大写单数（对应的库）
    const modelName = require('inflection').classify(req.params.resource)
    // 引入相应的模型，防止其他块访问不到，挂载到req上
    req.Model = require(`../../models/${modelName}`)
    // 中间件函数一定要next()
    next()
}
```

在总的路由这里加上登录验证的校验，包含了所有的增删改查

```js
app.use('/admin/api/rest/:resource', authMiddleware, resourceMiddleware, router)
```

在上传文件的接口加上登录验证的校验

```js
app.post('/admin/api/upload', authMiddleware, upload.single('file'),async(req, res) => {
    const file = req.file
    // filename就是保存在uploads中的文件名，给file增加url属性，就是图片的地址
    file.url = `http://localhost:3000/uploads/${file.filename}`
    res.send(file)
})
```

现在如果前端没有token，就会抛出错误，由前面的错误处理函数来处理，未登录都返回401的状态码，错误信息是请先登录

#### 5.2 前端请求

admin > http.js

前端请求前，都会加上带有token的请求头

响应前，如果状态码是401，就跳转到登录页面

```js
import axios from 'axios'
import Vue from 'vue'
// 引入路由
import router from './router'

const http = axios.create({
  baseURL: 'http://localhost:3000/admin/api'
})

// 请求拦截，请求的时候加上一个请求头，值为token
http.interceptors.request.use(function(config) {
  // 如果token存在，就加上这个请求头
  if(localStorage.token) {
    // 加上'Bearer '更符合规范，有空格
    config.headers.Authorization = 'Bearer ' + localStorage.token
  }  
  return config
})

// 响应拦截器，所有组件的axios响应都会经过这里
http.interceptors.response.use(res => {
  return res
}, err => {
  // err.response: 响应的数据，响应头，状态码等
  // err.response.data就是send的参数，{message: "用户名不存在"}
  // 如果出错，就弹出错误信息，把element的$message挂载到Vue的原型上
  if(err.response.data.message) {
    Vue.prototype.$message({
      type: 'error',
      message: err.response.data.message
    })
  }
  // 如果返回了401,就跳到登录页，需要前后端协商，
  // 后端如果需要登录，就返回状态码401
  if(err.response.status === 401) {
    router.push('/login')
  }
  return Promise.reject(err)
})
export default http
```

### 6. 抽离中间件

为了避免server > admin > index.js过于臃肿，将中间件抽离

server下新建middleware，middleware下新建auth.js resouce.js

注意路径的改变，并且将需要的模块导入，由于导出的是函数，所以使用的时候需要调用

auth.js

```js
/* 登录校验中间件 */
module.exports = options => {
  const AdminUser = require('../models/AdminUser')
  // 引入jwt
  const jwt = require('jsonwebtoken')
  // http错误处理
  const assert = require('http-assert')
  return async (req, res, next) => {   
    // 从请求头中获取token，后端用小写
    // 根据空格分割字符串，第二个才是token
    const token = String(req.headers.authorization || '').split(' ').pop()
    // 验证token存在
    assert(token, 401, '请先登录')
    // 最终会解析出来{id: .....}，也就是用于生成token的东西
    // req.app 等同与 app是express规定的
    const { id } = jwt.verify(token, req.app.get('secret'))
    // 验证id存在
    assert(id, 401, '请先登录')
    req.user = await AdminUser.findById(id)
    // 以上三步，token,id,req.user任意一步有问题都应该报错
    assert(req.user, 401, '请先登录')
    await next()
  }
}
```

resouce.js

```js
module.exports = options => {
  return async (req, res, next) => {
    // 小写复数（req.params.resource）转大写单数（对应的库）
    const modelName = require('inflection').classify(req.params.resource)
    // 引入相应的模型，防止其他块访问不到，挂载到req上
    req.Model = require(`../models/${modelName}`)
    // 中间件函数一定要next()
    next()
  }
}
```

### 7. 客户端路由限制

虽然服务端加了登录校验，但是只会在请求了后端接口的时候才会验证。新建分类等页面，只有路由跳转，没有请求接口，仍然可以正常访问，所以需要导航守卫，只有登录页可以公开访问

```js
// 加上isPublic: true，标识这个接口是可以公开访问的
{path: '/login', name: 'login', component: Login, meta: {isPublic: true}},
```

```js
// 导航守卫，
router.beforeEach((to, from, next) => {
  // 如果去的页面不是公开的，而且又没有token，就跳转到登录页
  if(!to.meta.isPublic && !localStorage.token) {
    return next('/login')
  }
  next()
})
```

### 8. 上传文件的修复

登录校验都是在请求拦截中写的，给每个aixos请求都加上了auth的请求头，所以增删改查能够有登录校验，但是文件上传是element自带的请求，需要另外的处理

admin > main.js

```js
// 现在全局拥有了getAuthHeaders方法，uploadUrl属性
Vue.mixin({
  computed: {
    uploadUrl() {
      return this.$http.defaults.baseURL + '/upload'
    }
  },
  methods: {
    getAuthHeaders() {
      return {
        Authorization: `Bearer ${localStorage.token || ''}`
      }
    }
  }
}) 
```

需要上传文件的地方都加上请求头

```html
<el-upload
    class="avatar-uploader"
    :action="uploadUrl"
    :show-file-list="false"
    :on-success="afterUpload"
    :headers="getAuthHeaders()"
    >
```

## 九. 密码

```
admin 12345
hmh12345 hmh6861860
```



## 二十. 查漏补缺

### 1. element

```
el-menu el-summenu index="1"
el-container 
el-aside 
el-form 
this.$message
el-table template scope.row
el-button native-type type
messageBox
upload
el-rate
el-tabs
el-icon-plus
el-row type=""
el-col :md=""
el-card header
```

### 2. express

```

​```js
1. express.Router()

2. // 前端请求，this.model就是req.body
const res = await this.$http.post('categories', this.model)
// 后台接口
router.post('/categories', async (req, res) => {
    // 根据req.body创建文档，并将数据库中的文档传给客户端
    const model = await Category.create(req.body)
    res.send(model)
})

3. req res 

4. axios 后续的地址，router加/，网络请求不加/，这是为什么呢
	加/也能请求，可能加不加都可以
5. inflection库：大小写转换用
6. multer: 处理文件上传的中间件
7. 静态文件托管
8. return res.status(422).send({
        message: '用户不存在'
      })
9. bcrypt 格式转换
10. jwt token 
11. http-assert 
12. vue2-editor 富文本编辑器
13. app.get() app.set()
14. req.app 等同于 app 都是express的实例
15. multer
```

https://blog.csdn.net/wang839305939/article/details/78713124/ 鉴权

### 3. mongoose

```

1. 查找方法
    Category.findById(req.params.id) // 查找方法
    findByIdAndUpdata
    andDelete
2. 集合关联 存id，取完整文档
    parent: { type: mongoose.SchemaTypes.ObjectId, ref: 'Category'}
    populate
3. setOptions
4. Model.modelname: 模型名称
5. 字段的值嵌套对象和数组
    scores: { 
        difficult: {type: Number},
        skills: {type: Number},
        attack: {type: Number},
        survive: {type: Number},
      },
      // 技能有多个，而且每个技能也有多个指标，名称图标简介等
      skills: [{
        icon: { type: String },
        name: { type: String },
        description: { type: String },
        tips: { type: String }
      }],
6. 字段属性：select, type, set(val) 
7. .select('+password')
```

### 4. vue

```
1. 
    方式一：this.$set(this.model, icon, res.url) // 新增属性用这个实现响应式
    方式二：需要的属性现在data中初始化 
2. props里的id，直接用this.id就可以获取
3. v-for的时候可以用item of items
4. Vue.mixin
```

### 5. http

```
204
422
401：用户身份错误
请求头
Authorization
```

### 6. js

```
1. Object.assign 
   this.model = Object.assign({}, this.model, res.data)
```

### 7. axios

```
return res.status(422).send({
        message: '用户不存在'
      })
```

